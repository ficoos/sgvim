#!/usr/bin/python
#
# Copyright 2012 Saggi Mizrahi
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
#
# Refer to the README and COPYING files for full details of the license
#

import SocketServer
import threading
import subprocess
import sys
import os
import base64
import shutil
import pwd

from Queue import Queue

PORT_RANGE = xrange(49152, 65535)


class SGvimHandler(SocketServer.BaseRequestHandler):
    def handle(self):
        remote_host = self.client_address[0]
        path = self.request.recv(1024).strip()
        sock_path = get_ssh_sock_path()
        gvim_cmd = ':let g:netrw_sftp_cmd = "sftp -o ControlPath=%s"' % \
            (sock_path,)
        remote_path = "sftp://%s/%s" % (remote_host, path)

        subprocess.Popen(["gvim", "--cmd", gvim_cmd, remote_path])


def start_listener(resp_chan):
    for port in PORT_RANGE:
        try:
            server = SocketServer.TCPServer(("localhost", port), SGvimHandler)
            break
        except:
            pass

    resp_chan.put_nowait(port)
    del resp_chan
    server.serve_forever()


def get_system_dir():
    system_dir = "/tmp/sgvim_%d" % (os.getpid(),)
    try:
        os.makedirs(system_dir)
    except (OSError, IOError):
        pass
    return system_dir


def get_ssh_sock_path():
    system_dir = get_system_dir()
    return os.path.join(system_dir, "ssh.sock")


def generate_install_script(port):
    with open(__file__, "r") as f:
        install_code = ''.join((s.strip()
                               for s in base64.encodestring(f.read())))

    return "python -c \"`echo %s | base64 -d`\" install %d" % \
           (install_code, port)


# This runs on the target host
def install_custom_gvim(port):
    base_dir = "/tmp/sgvim_s_%d" % (os.getpid(),)
    os.makedirs(base_dir)
    gvim_path = os.path.join(base_dir, "gvim")
    with open(gvim_path, "w") as f:
        f.write("#!/bin/sh\n")
        f.write('echo `readlink -f "$@"` | nc localhost %d\n' % (port,))

    os.chmod(gvim_path, 0555)  # 0555/-r-xr-xr-x
    e = os.environ.copy()
    e['PATH'] = "%s:%s" % (base_dir, e['PATH'])
    shell = pwd.getpwuid(os.geteuid()).pw_shell
    os.execvpe(shell, [], e)


def run_ssh(host, local_port, remote_port):
    sock_path = get_ssh_sock_path()
    subprocess.call(["ssh", host, "-M", "-S", sock_path, "-t", "-R",
                     "%d:localhost:%d" % (local_port, remote_port),
                     "%s" %
                     (generate_install_script(remote_port),)])


def main():
    if len(sys.argv) == 3:
        if sys.argv[1] == "install":
            install_custom_gvim(int(sys.argv[2]))
            return

    port_chan = Queue()
    t = threading.Thread(target=start_listener, args=(port_chan,))
    t.setDaemon(True)
    t.start()
    port = port_chan.get()
    del port_chan

    remote_host = sys.argv[1]
    # TODO: Make sure port is free on target aswell
    try:
        run_ssh(remote_host, port, port)
    finally:
        shutil.rmtree(get_system_dir())

if __name__ == "__main__":
    main()
